/*
** SPDX-License-Identifier: MIT
** X-SPDX-Copyright-Text: Copyright (C) 2022, Advanced Micro Devices, Inc.
*/

/**
 * \node{sc_vss}
 *
 * \brief Replace packet buffer timestamp with timestamp generated by VSS
 * packet broker, and demultiplex by VSS port.
 *
 * \nodedetails
 * This node is used with VSS packet brokers.  These devices append a
 * record to packets which can include one or both of a timestamp and a
 * port number.
 *
 * If a timestamp is present, then it replaces the SolarCapture timestamp.
 * If the port field is present it is used to select an outgoing link.  If
 * the port field is not present, the port is treated as 0.
 *
 * Outgoing links whose name is an integer receive packets with the
 * corresponding VSS port.  An outgoing link named "" receives any packets
 * whose port does not match a named outgoing link.
 *
 * \nodeargs
 * Argument      | Optional? | Default | Type           | Description
 * ------------- | --------- | ------- | -------------- | -------------------------------------------------------------------------------------------------------
 * strip         | Yes       | 1       | ::SC_PARAM_INT | Whether to strip the VSS record
 * timestamp     | Yes       | 1       | ::SC_PARAM_INT | Whether the timestamp field is present in the VSS record
 * portstamp     | Yes       | 1       | ::SC_PARAM_INT | Whether the port field is present in the VSS record
 *
 * \cond NODOC
 */
#include <sc_internal.h>
#include <sc_internal/builtin_nodes.h>

#include <errno.h>
#include <assert.h>
#include <arpa/inet.h>


struct sc_vss {
  int                        encap_bytes;
  int                        strip_bytes;
  const struct sc_node_link* next_hop[256];
};


union vss_encap {
  uint8_t    u8[1];
  struct {
    uint32_t secs;
    uint32_t nanos_and_src;
    uint8_t  port_after_timestamp;
  };
};


static void sc_vss_pkts(struct sc_node* node, struct sc_packet_list* pl)
{
  struct sc_vss* st = node->nd_private;
  struct sc_packet* next;
  struct sc_packet* pkt;
  union vss_encap vss;

  for( next = pl->head; (pkt = next) && ((next = next->next), 1); ) {
    /* If both port and timestamp are present, then timestamp comes first. */
    sc_iovec_copy_from_end(vss.u8, pkt->iov, pkt->iovlen, st->encap_bytes);
    int port_off = 0, port = 0;
    if( st->encap_bytes >= 8 ) {
      pkt->ts_sec = ntohl(vss.secs);
      pkt->ts_nsec = ntohl(vss.nanos_and_src) & 0x3fffffff;
      port_off = 8;
    }
    if( st->encap_bytes & 1 )
      port = vss.u8[port_off];
    pkt->frame_len -= st->strip_bytes;
    sc_iovec_trim_end(pkt->iov, &pkt->iovlen, st->strip_bytes);
    sc_forward(node, st->next_hop[port], pkt);
  }
}


static void sc_vss_end_of_stream(struct sc_node* node)
{
  struct sc_vss* st = node->nd_private;
  int i;
  for( i = 0; i < 256; ++i )
    sc_node_link_end_of_stream(node, st->next_hop[i]);
}


static int sc_vss_prep(struct sc_node* node,
                          const struct sc_node_link*const* links, int n_links)
{
  struct sc_vss* st = node->nd_private;
  int i, port;
  char dummy;
  for( i = 0; i < n_links; ++i )
    if( ! strcmp(links[i]->name, "") ) {
      ;
    }
    else if( sscanf(links[i]->name, "%d%c", &port, &dummy) == 1 &&
             port >= 0 && port < 256 ) {
      st->next_hop[port] = links[i];
    }
    else {
      sc_node_set_error(node, EINVAL, "sc_vss: ERROR: bad link '%s'\n",
                        links[i]->name);
      return -1;
    }
  for( i = 0; i < 256; ++i )
    if( st->next_hop[i] == NULL )
      st->next_hop[i] = sc_node_prep_get_link_or_free(node, "");
  return 0;
}


static int sc_vss_init(struct sc_node* node, const struct sc_attr* attr,
                          const struct sc_node_factory* factory)
{
  static struct sc_node_type* nt;
  if( nt == NULL ) {
    sc_node_type_alloc(&nt, NULL, factory);
    nt->nt_pkts_fn = sc_vss_pkts;
    nt->nt_prep_fn = sc_vss_prep;
    nt->nt_end_of_stream_fn = sc_vss_end_of_stream;
  }
  node->nd_type = nt;

  struct sc_vss* st;
  st = sc_thread_calloc(sc_node_get_thread(node), sizeof(*st));
  node->nd_private = st;

  int strip, timestamp, portstamp;
  if( sc_node_init_get_arg_int(&strip, node, "strip", 1) < 0 )
    goto error;
  if( sc_node_init_get_arg_int(&timestamp, node, "timestamp", 1) < 0 )
    goto error;
  if( sc_node_init_get_arg_int(&portstamp, node, "portstamp", 1) < 0 )
    goto error;

  st->encap_bytes = !! timestamp * 8 + !! portstamp * 1;
  st->strip_bytes = !! strip * st->encap_bytes;
  return 0;

 error:
  sc_thread_mfree(sc_node_get_thread(node), st);
  return -1;
}


const struct sc_node_factory sc_vss_sc_node_factory = {
  .nf_node_api_ver   = SC_API_VER,
  .nf_name           = "sc_vss",
  .nf_source_file    = __FILE__,
  .nf_init_fn        = sc_vss_init,
};
/** \endcond NODOC */
